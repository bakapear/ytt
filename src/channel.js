let { YoutubeChannel, YoutubeVideo, YoutubePlaylist } = require('./lib/structs')
let util = require('./lib/util')
let req = require('./lib/request')

module.exports = async (channelId) => {
  if (typeof channelId !== 'string') throw Error('Invalid value')

  let body = await req.api('browse', { browseId: channelId, params: genToken('about') })
  if (!body || !body.contents) throw Error('Invalid channel')

  let chan = makeChannelObject(body)

  return util.removeEmpty(chan)
}

module.exports.videos = async (channelId, sortType) => {
  if (typeof channelId !== 'string') throw Error('Invalid value')

  let body = await req.api('browse', { browseId: channelId, params: genToken('videos', sortType || 0) })
  if (!body || !body.contents) throw Error('Invalid channel')

  return await util.more(fetchContents, body)
}

module.exports.playlists = async (channelId, sortType) => {
  if (typeof channelId !== 'string') throw Error('Invalid value')

  let body = await req.api('browse', { browseId: channelId, params: genToken('playlists', sortType || 0) })
  if (!body || !body.contents) throw Error('Invalid channel')

  return await util.more(fetchContents, body)
}

module.exports.channels = async (channelId, sortType) => {
  if (typeof channelId !== 'string') throw Error('Invalid value')

  let body = await req.api('browse', { browseId: channelId, params: genToken('channels', sortType || 0) })
  if (!body || !body.contents) throw Error('Invalid channel')

  return await util.more(fetchContents, body)
}

function makeChannelObject (data) {
  if (!data.microformat) {
    let header = data.header.carouselHeaderRenderer
    if (!header) throw Error('Channel type not supported')
    header = data.header.carouselHeaderRenderer.contents[1].topicChannelDetailsRenderer
    return new YoutubeChannel({
      id: data.contents.twoColumnBrowseResultsRenderer.tabs[0].tabRenderer.tabIdentifier,
      title: util.text(header.title),
      subscribers: util.num(header.subtitle),
      avatar: header.avatar.thumbnails
    })
  }

  let header = data.header?.c4TabbedHeaderRenderer || data.header?.interactiveTabbedHeaderRenderer || {}
  let meta = data.metadata?.channelMetadataRenderer || {}
  let micro = data.microformat.microformatDataRenderer
  let tabs = data.contents?.twoColumnBrowseResultsRenderer.tabs
  let about = tabs?.find(x => x.tabRenderer.selected).tabRenderer
    .content.sectionListRenderer.contents[0].itemSectionRenderer
    .contents[0].channelAboutFullMetadataRenderer

  let game = header.metadata ? util.text(header.metadata).split(' â€¢ ') : null

  return new YoutubeChannel({
    id: util.between(micro.urlCanonical, '/channel/'),
    legacy: meta.doubleclickTrackingUsername || util.between(meta.vanityChannelUrl, '/user/'),
    custom: util.between(meta.vanityChannelUrl, '/c/'),
    verified: !!header.badges?.some(x => x.metadataBadgeRenderer.style === 'BADGE_STYLE_TYPE_VERIFIED'),
    generated: header.autoGenerated ? true : null,
    title: util.text(header.title) || micro.title,
    description: util.text(header.description) || util.text(about?.description) || micro.description,
    views: util.num(about?.viewCountText),
    subscribers: util.num(header.subscriberCountText),
    date: util.date(about?.joinedDateText),
    tags: micro.tags,
    labels: header.autoGenerated && header.badges ? header.badges.map(x => x.metadataBadgeRenderer.label) : null,
    year: game ? Number(game[0]) : null,
    devs: game ? game.slice(1) : null,
    avatar: [...meta.avatar?.thumbnails || [], ...header.avatar?.thumbnails || [], ...header.boxArt?.thumbnails || []],
    banner: header.banner ? [...header.banner.thumbnails, ...header.tvBanner?.thumbnails || [], ...header.mobileBanner?.thumbnails || []] : null
  })
}

function genToken (page, sortType) {
  return Buffer.from([18, ...util.stb(page), 24, sortType]).toString('base64')
}

async function fetchContents (next, data) {
  let res = []

  if (next) data = await req.api('browse', { continuation: next })
  else Object.defineProperty(res, 'channel', { value: util.removeEmpty(makeChannelObject(data)) })

  let contents = data.contents?.twoColumnBrowseResultsRenderer.tabs.find(x => x.tabRenderer.selected).tabRenderer.content.sectionListRenderer.contents[0].itemSectionRenderer.contents[0].gridRenderer.items
  if (!contents) contents = data.onResponseReceivedActions[0].appendContinuationItemsAction.continuationItems

  let token = contents[contents.length - 1].continuationItemRenderer
  if (token) token = token.continuationEndpoint.continuationCommand.token

  for (let item of contents) {
    let key = Object.keys(item)[0]
    switch (key) {
      case 'gridVideoRenderer': {
        let vid = item[key]
        res.push(new YoutubeVideo({
          id: vid.videoId,
          stream: util.text(vid.publishedTimeText)?.indexOf('Stream') !== -1 || null,
          labels: vid.badges?.map(x => x.metadataBadgeRenderer.label),
          thumbnail: vid.thumbnail.thumbnails,
          title: util.text(vid.title),
          description: util.text(vid.detailedMetadataSnippets?.[0].snippetText),
          date: util.date(vid.publishedTimeText),
          duration: util.time(vid.thumbnailOverlays[0].thumbnailOverlayTimeStatusRenderer.text),
          views: util.num(vid.viewCountText) || 0
        }))
        break
      }
      case 'gridPlaylistRenderer': {
        let list = item[key]
        res.push(new YoutubePlaylist({
          id: list.playlistId,
          title: util.text(list.title),
          thumbnail: list.thumbnail.thumbnails,
          size: util.num(list.videoCountText)
        }))
        break
      }
      case 'gridChannelRenderer': {
        let chan = item[key]
        res.push(new YoutubeChannel({
          id: chan.channelId,
          legacy: util.between(chan.navigationEndpoint.commandMetadata.webCommandMetadata.url, '/user/'),
          custom: util.between(chan.navigationEndpoint.commandMetadata.webCommandMetadata.url, '/c/'),
          title: util.text(chan.title),
          avatar: chan.thumbnail.thumbnails,
          size: util.num(chan.videoCountText),
          verified: !!chan.ownerBadges?.some(x => x.metadataBadgeRenderer.style === 'BADGE_STYLE_TYPE_VERIFIED'),
          subscribers: util.num(chan.subscriberCountText)
        }))
        break
      }
    }
  }

  return { items: util.removeEmpty(res), continuation: token || null }
}
